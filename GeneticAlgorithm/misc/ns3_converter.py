"""
Contains the necessary functions to convert the optimal solution given by the
Genetic algorithm into a format that is understandable to ns3.
"""
import os
import sys
import math
import argparse
from lxml import etree

script_path = os.path.dirname(os.path.abspath( __file__ ))
sys.path.append(script_path + '/../modules/')
from flow import Flow


def main():
    """
    Converts the Genetic Algorithm result to something that is understood by
    the ns3 simulator.
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('--ksp_xml_file', required=True,
                        help='The path to the KSP XML file')
    parser.add_argument('--ga_result_file', required=True,
                        help='The path to the GA result XML file.')
    parser.add_argument('--ksp_ns3_log_file', required=True,
                        help='The location of the ns3 log file generated by '
                             'the KSP algorithm')
    parser.add_argument('--output', required=True,
                        help='The location where to store the generated XML file')
    args = parser.parse_args()

    # Parse the KSP XML file and build the flows
    parser = etree.XMLParser(remove_blank_text=True)
    print('Parsing the KSP Xml file in {}'.format(args.ksp_xml_file))
    ksp_xml_root = etree.parse(args.ksp_xml_file).getroot()

    flows = Flow.parse_flows(ksp_xml_root)

    # Retrieve the last population
    ga_xml_root = etree.parse(args.ga_result_file).getroot()

    num_generations = int(ga_xml_root.find('Parameters').get('num_generations'))
    last_pop = ga_xml_root.xpath("//Generation[@number='{}']/Chromosome".format(num_generations))

    # Find the MaxFlow solution with no splits
    chromosome_index = -1
    max_flow = 0

    for idx, chromosome in enumerate(last_pop):
        net_flow = float(chromosome.get('net_flow'))
        tot_flow_splits = float(chromosome.get('tot_flow_splits'))
        if tot_flow_splits == 0 and net_flow > max_flow:
            max_flow = net_flow
            chromosome_index = idx

    assert chromosome_index > 0, 'No solution with no flow splits found'

    # Key: path id | Value: data rate on path
    best_solution = {int(gene.get('path_id')) : float(gene.get('value'))
                     for gene in last_pop[chromosome_index]}

    # Add ACK flows and append them to the best solution
    for flow_element in ksp_xml_root.findall('FlowDetails/Flow'):
        if flow_element.get('Protocol') == 'A':  # Parse ACK flows only
            flow = Flow(flow_element)

            if flow.id in flows:
                raise AssertionError('Flow id {} is duplicate'.format(flow.id))

            flows[flow.id] = flow

            assert len(flow.get_paths()) == 1, 'ACK flow should have only 1 path'
            path_id = flow.get_paths()[0].id
            assert path_id not in best_solution, 'Duplicate path id found'
            best_solution[path_id] = flow.requested_rate

    # Set very small numbers to 0
    for path_id in best_solution.keys():
        if best_solution[path_id] > 0 and math.isclose(best_solution[path_id], 0, abs_tol=1e-4):
            best_solution[path_id] = 0.0

    # Create XML document here
    root_element = etree.Element('Log')

    # # # Create Optimal Solution Element # # #
    optimal_soln_element = etree.SubElement(root_element, 'OptimalSolution')
    comment = ('DataRate (Mbps), PacketSize (bytes), Protocol (U=UDP,T=TCP), '
               'Time (Seconds).\nUnless Specified the port number refers to '
               'the destination port number')
    optimal_soln_element.append(etree.Comment(comment))

    for flow_id in sorted(flows):
        flow = flows[flow_id]
        flow_link_usage = dict()  # Key: link id | Value: total data rate on link
        flow_paths = flow.get_paths()
        for path in flow_paths:
            dr_on_path = best_solution[path.id]

            if dr_on_path > 0:
                for link_id in path.links:
                    if link_id in flow_link_usage:
                        flow_link_usage[link_id] += dr_on_path
                    else:
                        flow_link_usage[link_id] = dr_on_path

        flow_element = etree.SubElement(optimal_soln_element, 'Flow')
        flow_element.set('Id', str(flow.id))
        flow_element.set('SourceNode', str(flow.src_node))
        flow_element.set('DestinationNode', str(flow.dst_node))

        if flow.protocol == 'T':
            flow_element.set('SrcPortNumber', str(flow.src_port))
            flow_element.set('DstPortNumber', str(flow.dst_port))
        else:
            flow_element.set('PortNumber', str(flow.dst_port))

        allocated_data_rate = sum([best_solution[path.id] for path in flow_paths])
        flow_element.set('DataRate', str(allocated_data_rate))
        flow_element.set('RequestedDataRate', str(flow.requested_rate))
        flow_element.set('PacketSize', str(flow.pkt_size))
        flow_element.set('NumOfPackets', str(flow.num_packets))
        flow_element.set('Protocol', str(flow.protocol))
        flow_element.set('StartTime', str(flow.start_time))
        flow_element.set('EndTime', str(flow.end_time))

        for link_id in sorted(flow_link_usage.keys()):
            link_element = etree.SubElement(flow_element, 'Link')
            link_element.set('Id', str(link_id))
            link_element.set('FlowRate', str(flow_link_usage[link_id]))

    # # # Add incoming flow section # # #
    ksp_ns3_log_root = etree.parse(args.ksp_ns3_log_file).getroot()

    node_incoming_links = dict()  # Key -> Node Id Value -> List of incoming links of the node
    for link in ksp_ns3_log_root.findall('NetworkTopology/Link'):  # FIXME use the ns3log xml file here!
        for link_element in link.findall('LinkElement'):
            dst_node = int(link_element.get('DestinationNode'))
            link_id = int(link_element.get('Id'))

            if dst_node in node_incoming_links:
                node_incoming_links[dst_node].append(link_id)
            else:
                node_incoming_links[dst_node] = [link_id]

    incoming_flow_element = etree.SubElement(root_element, 'IncomingFlow')

    for node_id, links in sorted(node_incoming_links.items()):
        node_element = etree.SubElement(incoming_flow_element, 'Node')
        node_element.set('Id', str(node_id))

        flow_rate = dict()  # Key: Flow Id | Value: Incoming flow

        for flow_id in sorted(flows.keys()):
            flow = flows[flow_id]

            for path in flow.get_paths():
                if best_solution[path.id] > 0:
                    for link in path.links:
                        if link in links:  # Link exists
                            if flow_id in flow_rate:
                                flow_rate[flow_id] += best_solution[path.id]  # Get the data rate on that path
                            else:
                                flow_rate[flow_id] = best_solution[path.id]  # Get the data rate on that path

        for flow_id, incoming_flow in flow_rate.items():
            flow_element = etree.SubElement(node_element, 'Flow')
            flow_element.set('Id', str(flow_id))
            flow_element.set('IncomingFlow', str(incoming_flow))

    # Save XML file
    tree = etree.ElementTree(root_element)
    with open(args.output, 'wb') as output_file:
        tree.write(output_file, pretty_print=True, xml_declaration=True, encoding='utf-8')


if __name__ == "__main__":
    main()
