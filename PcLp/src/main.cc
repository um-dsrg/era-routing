#include <iostream>
#include <tinyxml2.h>
#include <lemon/lp.h>
#include <boost/program_options.hpp>

#include "lp_solver.h"
#include "definitions.h"
#include "xml_handler.h"
#include "path_file_parser.h"

namespace po = boost::program_options;

int
main (int argc, const char *argv[])
{
  std::string pathsXmlFile {""};

  std::vector<std::string> outputPaths;
  std::vector<std::string> optimisationProblems;

  try
  {
    po::options_description cmdLineParams("Allowed Options");
    cmdLineParams.add_options()
                  ("help", "Help Message")
                  ("input", po::value<std::string>(&pathsXmlFile)->required(),
                   "The path to XML result file generated by KSP")
                  ("optimisationProblems",
                   po::value<std::vector<std::string>>(&optimisationProblems)->multitoken(),
                   "List of optimisation problems to run. Available names are: "
                   "MinCost | FlowLimitedMinCost | MaxDelayDistribution | "
                   "MaxDelay. Note that all of the options will run the "
                   "Maximum Flow before hand. If multiple optimisation "
                   "problems are given the Maximum Flow solution will be kept "
                   "constant for all the different runs. This is important "
                   "when comparing solutions with each other. Each different "
                   "run generates its own XML result file.")
                  ("output",
                   po::value<std::vector<std::string>>(&outputPaths)->multitoken(),
                   "List of paths where to save the result of each of the given optimisation "
                   "problem");

    po::variables_map vm;
    po::store(po::parse_command_line(argc, argv, cmdLineParams), vm);

    if (vm.count("help")) // Output help message
    {
      std::cout << cmdLineParams << "\n";
      return EXIT_SUCCESS;
    }
    po::notify(vm); // Check if all required parameters are passed

    XmlHandler xmlHandler (pathsXmlFile);
    tinyxml2::XMLNode* rootNode = xmlHandler.getKspRootNode();

    linkContainer_t links;
    pathContainer_t paths;
    flowContainer_t flows;

    // Build the necessary data structures from the paths XML file
    parsePathFile(rootNode, links, paths, flows);

    if (optimisationProblems.size() != outputPaths.size())
    {
      throw std::runtime_error("The number of optimisation problems and output paths needs to be "
                               "identical");
    }

    LpSolver lpSolver (links, paths);

    lpSolver.SetFlows(&flows);

    // Solve the Maximum Flow Problem
    auto [maxFlowSolnFound, maxNetworkFlow] = lpSolver.solveMaxFlowProblem();

    if (maxFlowSolnFound == false)
    {
      std::cerr << "Maximum Network Flow solution NOT found" << std::endl;
      return EXIT_FAILURE;
    }

    for (auto index = 0; index < optimisationProblems.size(); ++index)
    {
      // Make a deep copy of the flow set to be used.
      // A deep copy is required because the flow set may be modified.
      flowContainer_t tempFlowSet;
      for (auto& flow: flows)
      {
        tempFlowSet.emplace_back(new Flow(*flow));
      }
      lpSolver.SetFlows(&tempFlowSet);

      lpSolver.ClearTimings();
      lpSolver.ClearObjectiveValues();

      // We need to repeat the same thing here for the different problems
      const auto& optimisationProblem {optimisationProblems[index]};

      auto optimalSolutionFound = bool{false};

      if (optimisationProblem == "MinCost")
      {
        std::cout << "Solving the Maximum Flow Minimum Cost problem..." << std::endl;
        optimalSolutionFound = lpSolver.MinCost(maxNetworkFlow);
      }
      else if (optimisationProblem == "FlowLimitedMinCost")
      {
        std::cout << "Solving the Maximum Flow Minimum Cost problem with each flow's assigned data "
                  << "rate set by Maximum Flow solution..." << std::endl;
        optimalSolutionFound = lpSolver.FlowLimitedMinCost(maxNetworkFlow);
      }
      else if (optimisationProblem == "MaxDelayDistribution")
      {
        std::cout << "Solving the Maximum Flow Maximum Delay Distribution metric problem"
                  << std::endl;
        optimalSolutionFound = lpSolver.MaxDelayDistributionMetric(maxNetworkFlow);
      }
      else
      {
        throw std::runtime_error(optimisationProblem + " is not supported");
      }

      if (optimalSolutionFound == false)
      {
        std::cerr << "Optimal Solution NOT found" << std::endl;
        return EXIT_FAILURE;
      }

      const auto& outputPath {outputPaths[index]};
      xmlHandler.saveResults(links, paths, tempFlowSet, lpSolver, outputPath);
    }
  }
  catch (std::exception& e)
  {
    std::cerr << "Error: " << e.what() << "\n";
    return EXIT_FAILURE;
  } catch (...)
  {
    return EXIT_FAILURE;
  }

  return EXIT_SUCCESS;
}
