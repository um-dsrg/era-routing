#include <iostream>
#include <tinyxml2.h>
#include <lemon/lp.h>
#include <boost/program_options.hpp>

#include "definitions.h"
#include "ksp_parser.h"
#include "lp_solver.h"
#include "xml_handler.h"

namespace po = boost::program_options;

int main (int argc, const char *argv[])
{
  std::string kspXmlPath {""};
  std::string resultXmlPath {""};

  try {
      po::options_description cmdLineParams("Allowed Options");
      cmdLineParams.add_options()
                    ("help", "Help Message")
                    ("input,i", po::value<std::string>(&kspXmlPath)->required(), "The path to XML result file generated by KSP")
                    ("output,o", po::value<std::string>(&resultXmlPath)->required(), "The path where to store the result file");

      po::variables_map vm;
      po::store(po::parse_command_line(argc, argv, cmdLineParams), vm);

      if (vm.count("help")) // Output help message
        {
          std::cout << cmdLineParams << "\n";
          return EXIT_SUCCESS;
        }
      po::notify(vm); // Check if all required parameters are passed

      XmlHandler xmlHandler (kspXmlPath);
      tinyxml2::XMLNode* rootNode = xmlHandler.GetKspRootNode();

      linkContainer_t links;
      pathContainer_t paths;
      flowContainer_t flows;

      // Build the necessary data structures from the KSP result file
      parseKspData(rootNode, links, paths, flows);

      LpSolver lpSolver (links, paths, flows);
      lpSolver.solve();

      std::cout << "Solution results" << std::endl;
      std::cout << "----------------" << std::endl;

      for (std::unique_ptr<Flow>& flow: flows)
        {
          std::cout << "Flow Id: " << flow->getId() << std::endl;

          for (Path* path : flow->getPaths())
            {
              std::cout << "  Path Id: " << path->getId()
                        << " Data Rate: " << lpSolver.getLpColValue(path->getDataRateLpVar())
                        << std::endl;
            }
        }
  } catch (std::exception& e)
  {
      std::cerr << "Error: " << e.what() << "\n";
      return EXIT_FAILURE;
  } catch (...)
  {
      return EXIT_FAILURE;
  }

  return EXIT_SUCCESS;
}
